# æ™ºèƒ½ä½“å¼€å‘æ¨¡æ¿ä¸æ¶æ„æŒ‡å—

> åŸºäº30ä¸ªå¼€æºæ™ºèƒ½ä½“æ¡†æ¶çš„æ·±åº¦åˆ†æï¼Œä¸ºæ™ºèƒ½ä½“å¼€å‘æä¾›å®Œæ•´çš„æ¶æ„æ¨¡æ¿å’Œæœ€ä½³å®è·µ

## ğŸ“‹ ç›®å½•

1. [æ™ºèƒ½ä½“æ¶æ„æ¦‚è§ˆ](#æ™ºèƒ½ä½“æ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒç»„ä»¶æ¶æ„å›¾](#æ ¸å¿ƒç»„ä»¶æ¶æ„å›¾)
3. [æ™ºèƒ½ä½“å¼€å‘æµç¨‹å›¾](#æ™ºèƒ½ä½“å¼€å‘æµç¨‹å›¾)
4. [æŠ€æœ¯æ ˆé€‰æ‹©æŒ‡å—](#æŠ€æœ¯æ ˆé€‰æ‹©æŒ‡å—)
5. [å¼€å‘æ¨¡æ¿ä»£ç ](#å¼€å‘æ¨¡æ¿ä»£ç )
6. [éƒ¨ç½²ä¸ç›‘æ§](#éƒ¨ç½²ä¸ç›‘æ§)
7. [æœ€ä½³å®è·µæ€»ç»“](#æœ€ä½³å®è·µæ€»ç»“)

---

## æ™ºèƒ½ä½“æ¶æ„æ¦‚è§ˆ

### ğŸ—ï¸ æ™ºèƒ½ä½“ç³»ç»Ÿæ¶æ„å±‚æ¬¡

```mermaid
graph TB
    subgraph "ç”¨æˆ·äº¤äº’å±‚"
        UI[ç”¨æˆ·ç•Œé¢]
        API[APIæ¥å£]
        CLI[å‘½ä»¤è¡Œå·¥å…·]
    end
    
    subgraph "æ™ºèƒ½ä½“ç¼–æ’å±‚"
        ORCH[æ™ºèƒ½ä½“ç¼–æ’å™¨]
        SCHED[ä»»åŠ¡è°ƒåº¦å™¨]
        COORD[åè°ƒå™¨]
    end
    
    subgraph "æ™ºèƒ½ä½“æ ¸å¿ƒå±‚"
        subgraph "ä»»åŠ¡è§„åˆ’æ¨¡å—"
            PLAN[ä»»åŠ¡åˆ†è§£å™¨]
            REASON[æ¨ç†å¼•æ“]
            PRIORITY[ä¼˜å…ˆçº§ç®¡ç†]
        end
        
        subgraph "è®°å¿†ä½“ç³»æ¨¡å—"
            SHORT[çŸ­æœŸè®°å¿†]
            LONG[é•¿æœŸè®°å¿†]
            PROCESS[è¿‡ç¨‹è®°å¿†]
        end
        
        subgraph "å·¥å…·è°ƒç”¨æ¨¡å—"
            TOOL[å·¥å…·æ³¨å†Œå™¨]
            EXEC[æ‰§è¡Œå¼•æ“]
            RESULT[ç»“æœå¤„ç†å™¨]
        end
        
        subgraph "è‡ªæ²»å¾ªç¯æ¨¡å—"
            REACT[ReActå¾ªç¯]
            REFLECT[è‡ªæˆ‘åæ€]
            ADAPT[è‡ªé€‚åº”è°ƒæ•´]
        end
        
        subgraph "å®‰å…¨æ§åˆ¶æ¨¡å—"
            AUTH[æƒé™ç®¡ç†]
            MONITOR[ç›‘æ§ç³»ç»Ÿ]
            GUARD[å®‰å…¨æŠ¤æ ]
        end
        
        subgraph "å¤šæ™ºèƒ½ä½“åä½œæ¨¡å—"
            COMM[é€šä¿¡åè®®]
            COOP[åä½œç­–ç•¥]
            NEGO[åå•†æœºåˆ¶]
        end
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚"
        LLM[å¤§è¯­è¨€æ¨¡å‹]
        VECTOR[å‘é‡æ•°æ®åº“]
        CACHE[ç¼“å­˜ç³»ç»Ÿ]
        LOG[æ—¥å¿—ç³»ç»Ÿ]
    end
    
    UI --> ORCH
    API --> ORCH
    CLI --> ORCH
    
    ORCH --> PLAN
    ORCH --> SCHED
    ORCH --> COORD
    
    PLAN --> SHORT
    REASON --> LONG
    PRIORITY --> PROCESS
    
    TOOL --> EXEC
    EXEC --> RESULT
    
    REACT --> REFLECT
    REFLECT --> ADAPT
    
    AUTH --> MONITOR
    MONITOR --> GUARD
    
    COMM --> COOP
    COOP --> NEGO
    
    SHORT --> LLM
    LONG --> VECTOR
    PROCESS --> CACHE
    
    EXEC --> LLM
    RESULT --> LOG
```

---

## æ ¸å¿ƒç»„ä»¶æ¶æ„å›¾

### ğŸ§  æ™ºèƒ½ä½“æ ¸å¿ƒæ¶æ„

```mermaid
graph LR
    subgraph "æ™ºèƒ½ä½“æ ¸å¿ƒ"
        subgraph "è¾“å…¥å¤„ç†"
            INPUT[ç”¨æˆ·è¾“å…¥]
            PARSE[è¾“å…¥è§£æ]
            VALIDATE[è¾“å…¥éªŒè¯]
        end
        
        subgraph "ä»»åŠ¡è§„åˆ’å¼•æ“"
            DECOMPOSE[ä»»åŠ¡åˆ†è§£]
            REASONING[æ¨ç†è§„åˆ’]
            SCHEDULING[ä»»åŠ¡è°ƒåº¦]
        end
        
        subgraph "è®°å¿†ç®¡ç†"
            CONTEXT[ä¸Šä¸‹æ–‡è®°å¿†]
            KNOWLEDGE[çŸ¥è¯†åº“]
            HISTORY[å†å²è®°å½•]
        end
        
        subgraph "å·¥å…·æ‰§è¡Œ"
            TOOL_SELECT[å·¥å…·é€‰æ‹©]
            TOOL_CALL[å·¥å…·è°ƒç”¨]
            RESULT_PROCESS[ç»“æœå¤„ç†]
        end
        
        subgraph "å†³ç­–å¾ªç¯"
            THINK[æ€è€ƒé˜¶æ®µ]
            ACT[è¡ŒåŠ¨é˜¶æ®µ]
            OBSERVE[è§‚å¯Ÿé˜¶æ®µ]
            REFLECT[åæ€é˜¶æ®µ]
        end
        
        subgraph "è¾“å‡ºç”Ÿæˆ"
            RESPONSE[å“åº”ç”Ÿæˆ]
            FORMAT[æ ¼å¼åŒ–]
            DELIVERY[è¾“å‡ºäº¤ä»˜]
        end
    end
    
    INPUT --> PARSE
    PARSE --> VALIDATE
    VALIDATE --> DECOMPOSE
    
    DECOMPOSE --> REASONING
    REASONING --> SCHEDULING
    
    SCHEDULING --> CONTEXT
    CONTEXT --> KNOWLEDGE
    KNOWLEDGE --> HISTORY
    
    HISTORY --> TOOL_SELECT
    TOOL_SELECT --> TOOL_CALL
    TOOL_CALL --> RESULT_PROCESS
    
    RESULT_PROCESS --> THINK
    THINK --> ACT
    ACT --> OBSERVE
    OBSERVE --> REFLECT
    
    REFLECT --> RESPONSE
    RESPONSE --> FORMAT
    FORMAT --> DELIVERY
```

---

## æ™ºèƒ½ä½“å¼€å‘æµç¨‹å›¾

### ğŸ”„ æ™ºèƒ½ä½“å¼€å‘ç”Ÿå‘½å‘¨æœŸ

```mermaid
flowchart TD
    START([å¼€å§‹å¼€å‘]) --> REQUIRE[éœ€æ±‚åˆ†æ]
    
    REQUIRE --> DESIGN[æ¶æ„è®¾è®¡]
    DESIGN --> CHOOSE[æŠ€æœ¯æ ˆé€‰æ‹©]
    
    CHOOSE --> SETUP[ç¯å¢ƒæ­å»º]
    SETUP --> CORE[æ ¸å¿ƒæ¨¡å—å¼€å‘]
    
    subgraph "æ ¸å¿ƒæ¨¡å—å¼€å‘"
        CORE --> PLAN[ä»»åŠ¡è§„åˆ’æ¨¡å—]
        PLAN --> MEMORY[è®°å¿†ä½“ç³»æ¨¡å—]
        MEMORY --> TOOL[å·¥å…·è°ƒç”¨æ¨¡å—]
        TOOL --> LOOP[è‡ªæ²»å¾ªç¯æ¨¡å—]
        LOOP --> SECURITY[å®‰å…¨æ§åˆ¶æ¨¡å—]
        SECURITY --> COLLAB[å¤šæ™ºèƒ½ä½“åä½œæ¨¡å—]
    end
    
    COLLAB --> INTEGRATION[æ¨¡å—é›†æˆ]
    INTEGRATION --> TEST[å•å…ƒæµ‹è¯•]
    
    TEST --> INTEGRATION_TEST[é›†æˆæµ‹è¯•]
    INTEGRATION_TEST --> PERFORMANCE[æ€§èƒ½æµ‹è¯•]
    PERFORMANCE --> SECURITY_TEST[å®‰å…¨æµ‹è¯•]
    
    SECURITY_TEST --> DEPLOY[éƒ¨ç½²]
    DEPLOY --> MONITOR[ç›‘æ§]
    MONITOR --> OPTIMIZE[ä¼˜åŒ–]
    
    OPTIMIZE --> MAINTENANCE[ç»´æŠ¤]
    MAINTENANCE --> UPDATE[æ›´æ–°è¿­ä»£]
    UPDATE --> REQUIRE
    
    OPTIMIZE --> END([å®Œæˆ])
```

### ğŸ¯ æ™ºèƒ½ä½“æ‰§è¡Œæµç¨‹å›¾

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Agent as æ™ºèƒ½ä½“
    participant Planner as ä»»åŠ¡è§„åˆ’å™¨
    participant Memory as è®°å¿†ç³»ç»Ÿ
    participant Tool as å·¥å…·ç³»ç»Ÿ
    participant LLM as å¤§è¯­è¨€æ¨¡å‹
    
    User->>Agent: è¾“å…¥ä»»åŠ¡
    Agent->>Planner: ä»»åŠ¡åˆ†è§£
    Planner->>Memory: æŸ¥è¯¢ç›¸å…³è®°å¿†
    Memory-->>Planner: è¿”å›ä¸Šä¸‹æ–‡
    Planner->>Agent: è¿”å›æ‰§è¡Œè®¡åˆ’
    
    loop æ‰§è¡Œå¾ªç¯
        Agent->>LLM: ç”Ÿæˆæ€è€ƒ
        LLM-->>Agent: è¿”å›æ€è€ƒç»“æœ
        Agent->>Tool: è°ƒç”¨å·¥å…·
        Tool-->>Agent: è¿”å›æ‰§è¡Œç»“æœ
        Agent->>Memory: æ›´æ–°è®°å¿†
        Agent->>LLM: åæ€å’Œè°ƒæ•´
        LLM-->>Agent: è¿”å›è°ƒæ•´å»ºè®®
    end
    
    Agent->>User: è¿”å›æœ€ç»ˆç»“æœ
```

---

## æŠ€æœ¯æ ˆé€‰æ‹©æŒ‡å—

### ğŸ› ï¸ æŠ€æœ¯æ ˆçŸ©é˜µ

| ç»„ä»¶ | æ¨èæŠ€æœ¯æ ˆ | å¤‡é€‰æ–¹æ¡ˆ | é€‚ç”¨åœºæ™¯ |
|------|------------|----------|----------|
| **å‰ç«¯æ¡†æ¶** | React/Vue | Angular/Svelte | å¯è§†åŒ–æ™ºèƒ½ä½“ç•Œé¢ |
| **åç«¯æ¡†æ¶** | FastAPI/Flask | Django/Express | APIæœåŠ¡å¼€å‘ |
| **AIæ¡†æ¶** | LangChain/LangGraph | LlamaIndex/Semantic Kernel | æ™ºèƒ½ä½“ç¼–æ’ |
| **å¤šæ™ºèƒ½ä½“** | CrewAI/AutoGen | CAMEL/Swarms | å¤šæ™ºèƒ½ä½“åä½œ |
| **æ•°æ®åº“** | PostgreSQL/MongoDB | Redis/Chroma | æ•°æ®å­˜å‚¨ |
| **å‘é‡æ•°æ®åº“** | Pinecone/Weaviate | Qdrant/Milvus | å‘é‡æœç´¢ |
| **æ¶ˆæ¯é˜Ÿåˆ—** | Redis/RabbitMQ | Apache Kafka | å¼‚æ­¥é€šä¿¡ |
| **ç›‘æ§** | Prometheus/Grafana | ELK Stack | ç³»ç»Ÿç›‘æ§ |
| **éƒ¨ç½²** | Docker/Kubernetes | Docker Compose | å®¹å™¨åŒ–éƒ¨ç½² |

### ğŸ“Š æ¡†æ¶é€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    START([é€‰æ‹©æ™ºèƒ½ä½“æ¡†æ¶]) --> SINGLE{å•æ™ºèƒ½ä½“è¿˜æ˜¯å¤šæ™ºèƒ½ä½“?}
    
    SINGLE -->|å•æ™ºèƒ½ä½“| SIMPLE{å¤æ‚åº¦è¦æ±‚?}
    SINGLE -->|å¤šæ™ºèƒ½ä½“| MULTI{åä½œæ¨¡å¼?}
    
    SIMPLE -->|ç®€å•| LANGCHAIN[LangChain]
    SIMPLE -->|å¤æ‚| LANGGRAPH[LangGraph]
    
    MULTI -->|å¯¹è¯å¼| AUTOGEN[AutoGen]
    MULTI -->|è§’è‰²æ‰®æ¼”| CREWAI[CrewAI]
    MULTI -->|ç¾¤ä½“åä½œ| SWARMS[Swarms]
    MULTI -->|é€šä¿¡åè®®| CAMEL[CAMEL]
    
    LANGCHAIN --> DEPLOY[éƒ¨ç½²é€‰æ‹©]
    LANGGRAPH --> DEPLOY
    AUTOGEN --> DEPLOY
    CREWAI --> DEPLOY
    SWARMS --> DEPLOY
    CAMEL --> DEPLOY
    
    DEPLOY --> CLOUD{äº‘éƒ¨ç½²è¿˜æ˜¯æœ¬åœ°?}
    CLOUD -->|äº‘éƒ¨ç½²| AWS[AWS/Azure/GCP]
    CLOUD -->|æœ¬åœ°| DOCKER[Docker/K8s]
```

---

## å¼€å‘æ¨¡æ¿ä»£ç 

### ğŸ Pythonæ™ºèƒ½ä½“åŸºç¡€æ¨¡æ¿

```python
# agent_template.py
from typing import Dict, List, Any, Optional
from abc import ABC, abstractmethod
import asyncio
import logging
from dataclasses import dataclass
from enum import Enum

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AgentState(Enum):
    IDLE = "idle"
    THINKING = "thinking"
    ACTING = "acting"
    OBSERVING = "observing"
    REFLECTING = "reflecting"

@dataclass
class Task:
    id: str
    description: str
    priority: int
    status: str
    context: Dict[str, Any]

@dataclass
class Memory:
    short_term: Dict[str, Any]
    long_term: Dict[str, Any]
    process: List[Dict[str, Any]]

class Tool(ABC):
    """å·¥å…·åŸºç±»"""
    
    @abstractmethod
    async def execute(self, **kwargs) -> Any:
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        pass

class TaskPlanner:
    """ä»»åŠ¡è§„åˆ’å™¨"""
    
    def __init__(self):
        self.tasks = []
    
    async def decompose_task(self, task_description: str) -> List[Task]:
        """ä»»åŠ¡åˆ†è§£"""
        # å®ç°ä»»åŠ¡åˆ†è§£é€»è¾‘
        pass
    
    async def prioritize_tasks(self, tasks: List[Task]) -> List[Task]:
        """ä»»åŠ¡ä¼˜å…ˆçº§æ’åº"""
        return sorted(tasks, key=lambda x: x.priority, reverse=True)

class MemoryManager:
    """è®°å¿†ç®¡ç†å™¨"""
    
    def __init__(self):
        self.memory = Memory(
            short_term={},
            long_term={},
            process=[]
        )
    
    async def store_short_term(self, key: str, value: Any):
        """å­˜å‚¨çŸ­æœŸè®°å¿†"""
        self.memory.short_term[key] = value
    
    async def store_long_term(self, key: str, value: Any):
        """å­˜å‚¨é•¿æœŸè®°å¿†"""
        self.memory.long_term[key] = value
    
    async def store_process(self, step: Dict[str, Any]):
        """å­˜å‚¨è¿‡ç¨‹è®°å¿†"""
        self.memory.process.append(step)

class ToolManager:
    """å·¥å…·ç®¡ç†å™¨"""
    
    def __init__(self):
        self.tools: Dict[str, Tool] = {}
    
    def register_tool(self, tool: Tool):
        """æ³¨å†Œå·¥å…·"""
        self.tools[tool.name] = tool
    
    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """æ‰§è¡Œå·¥å…·"""
        if tool_name not in self.tools:
            raise ValueError(f"Tool {tool_name} not found")
        return await self.tools[tool_name].execute(**kwargs)

class Agent:
    """æ™ºèƒ½ä½“æ ¸å¿ƒç±»"""
    
    def __init__(self, name: str):
        self.name = name
        self.state = AgentState.IDLE
        self.task_planner = TaskPlanner()
        self.memory_manager = MemoryManager()
        self.tool_manager = ToolManager()
        self.current_task: Optional[Task] = None
    
    async def think(self, input_data: str) -> str:
        """æ€è€ƒé˜¶æ®µ"""
        self.state = AgentState.THINKING
        logger.info(f"{self.name} is thinking...")
        
        # å®ç°æ€è€ƒé€»è¾‘
        thoughts = f"Processing: {input_data}"
        await self.memory_manager.store_short_term("current_thoughts", thoughts)
        
        return thoughts
    
    async def act(self, action: str, **kwargs) -> Any:
        """è¡ŒåŠ¨é˜¶æ®µ"""
        self.state = AgentState.ACTING
        logger.info(f"{self.name} is acting: {action}")
        
        # æ‰§è¡Œå·¥å…·è°ƒç”¨
        result = await self.tool_manager.execute_tool(action, **kwargs)
        
        # è®°å½•è¿‡ç¨‹
        await self.memory_manager.store_process({
            "action": action,
            "kwargs": kwargs,
            "result": result,
            "timestamp": asyncio.get_event_loop().time()
        })
        
        return result
    
    async def observe(self, result: Any) -> str:
        """è§‚å¯Ÿé˜¶æ®µ"""
        self.state = AgentState.OBSERVING
        logger.info(f"{self.name} is observing result...")
        
        # åˆ†æç»“æœ
        observation = f"Observed result: {result}"
        await self.memory_manager.store_short_term("last_observation", observation)
        
        return observation
    
    async def reflect(self, observation: str) -> str:
        """åæ€é˜¶æ®µ"""
        self.state = AgentState.REFLECTING
        logger.info(f"{self.name} is reflecting...")
        
        # åæ€å’Œè°ƒæ•´
        reflection = f"Reflection on: {observation}"
        await self.memory_manager.store_long_term("reflection", reflection)
        
        return reflection
    
    async def react_loop(self, input_data: str) -> str:
        """ReActå¾ªç¯"""
        logger.info(f"{self.name} starting ReAct loop with: {input_data}")
        
        # æ€è€ƒ
        thoughts = await self.think(input_data)
        
        # è¡ŒåŠ¨
        action_result = await self.act("process_input", data=input_data)
        
        # è§‚å¯Ÿ
        observation = await self.observe(action_result)
        
        # åæ€
        reflection = await self.reflect(observation)
        
        self.state = AgentState.IDLE
        return f"Processed: {input_data} -> {action_result}"

# ç¤ºä¾‹å·¥å…·å®ç°
class CalculatorTool(Tool):
    """è®¡ç®—å™¨å·¥å…·"""
    
    @property
    def name(self) -> str:
        return "calculator"
    
    async def execute(self, operation: str, **kwargs) -> float:
        """æ‰§è¡Œè®¡ç®—"""
        try:
            result = eval(operation)
            return float(result)
        except Exception as e:
            raise ValueError(f"Invalid operation: {operation}, Error: {e}")

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    # åˆ›å»ºæ™ºèƒ½ä½“
    agent = Agent("MyAgent")
    
    # æ³¨å†Œå·¥å…·
    calculator = CalculatorTool()
    agent.tool_manager.register_tool(calculator)
    
    # æ‰§è¡Œä»»åŠ¡
    result = await agent.react_loop("Calculate 2 + 2")
    print(f"Result: {result}")

if __name__ == "__main__":
    asyncio.run(main())
```

### ğŸ”§ é…ç½®æ–‡ä»¶æ¨¡æ¿

```yaml
# config.yaml
agent:
  name: "MyAgent"
  version: "1.0.0"
  description: "A sample AI agent"

memory:
  short_term:
    max_size: 1000
    ttl: 3600  # seconds
  long_term:
    storage_type: "vector_db"
    collection_name: "agent_memory"
  process:
    max_steps: 100

tools:
  - name: "calculator"
    type: "builtin"
    enabled: true
  - name: "web_search"
    type: "external"
    enabled: true
    api_key: "${WEB_SEARCH_API_KEY}"

llm:
  provider: "openai"
  model: "gpt-4"
  temperature: 0.7
  max_tokens: 2000

security:
  max_iterations: 10
  timeout: 300  # seconds
  rate_limit: 100  # requests per minute

monitoring:
  enabled: true
  log_level: "INFO"
  metrics_endpoint: "http://localhost:9090/metrics"
```

### ğŸ³ Dockeré…ç½®æ¨¡æ¿

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .

# å®‰è£…Pythonä¾èµ–
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["python", "main.py"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  agent:
    build: .
    ports:
      - "8000:8000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - DATABASE_URL=${DATABASE_URL}
    volumes:
      - ./data:/app/data
    depends_on:
      - redis
      - postgres

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=agent_db
      - POSTGRES_USER=agent
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  monitoring:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml

volumes:
  redis_data:
  postgres_data:
```

---

## éƒ¨ç½²ä¸ç›‘æ§

### ğŸ“Š ç›‘æ§æŒ‡æ ‡

```python
# monitoring.py
from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time

# å®šä¹‰ç›‘æ§æŒ‡æ ‡
agent_requests_total = Counter('agent_requests_total', 'Total agent requests', ['agent_name'])
agent_request_duration = Histogram('agent_request_duration_seconds', 'Agent request duration')
agent_memory_usage = Gauge('agent_memory_usage_bytes', 'Agent memory usage')
agent_active_tasks = Gauge('agent_active_tasks', 'Number of active tasks')

class AgentMonitor:
    """æ™ºèƒ½ä½“ç›‘æ§å™¨"""
    
    def __init__(self, agent_name: str):
        self.agent_name = agent_name
    
    def record_request(self, duration: float):
        """è®°å½•è¯·æ±‚"""
        agent_requests_total.labels(agent_name=self.agent_name).inc()
        agent_request_duration.observe(duration)
    
    def update_memory_usage(self, usage: int):
        """æ›´æ–°å†…å­˜ä½¿ç”¨é‡"""
        agent_memory_usage.set(usage)
    
    def update_active_tasks(self, count: int):
        """æ›´æ–°æ´»è·ƒä»»åŠ¡æ•°"""
        agent_active_tasks.set(count)
```

### ğŸ” æ—¥å¿—é…ç½®

```python
# logging_config.py
import logging
import logging.config
import json
from datetime import datetime

LOGGING_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        },
        "json": {
            "format": "%(asctime)s",
            "class": "pythonjsonlogger.jsonlogger.JsonFormatter"
        }
    },
    "handlers": {
        "default": {
            "level": "INFO",
            "formatter": "standard",
            "class": "logging.StreamHandler",
            "stream": "ext://sys.stdout"
        },
        "file": {
            "level": "DEBUG",
            "formatter": "json",
            "class": "logging.handlers.RotatingFileHandler",
            "filename": "logs/agent.log",
            "maxBytes": 10485760,  # 10MB
            "backupCount": 5
        }
    },
    "loggers": {
        "": {
            "handlers": ["default", "file"],
            "level": "DEBUG",
            "propagate": False
        }
    }
}

def setup_logging():
    """è®¾ç½®æ—¥å¿—é…ç½®"""
    logging.config.dictConfig(LOGGING_CONFIG)
```

---

## æœ€ä½³å®è·µæ€»ç»“

### âœ… å¼€å‘æœ€ä½³å®è·µ

1. **æ¨¡å—åŒ–è®¾è®¡**
   - å°†æ™ºèƒ½ä½“åŠŸèƒ½æ‹†åˆ†ä¸ºç‹¬ç«‹æ¨¡å—
   - ä½¿ç”¨æ¥å£å’ŒæŠ½è±¡ç±»å®šä¹‰æ ‡å‡†
   - ä¿æŒæ¨¡å—é—´çš„æ¾è€¦åˆ

2. **é”™è¯¯å¤„ç†**
   - å®ç°å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶
   - æä¾›ä¼˜é›…çš„é™çº§ç­–ç•¥
   - è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—

3. **æ€§èƒ½ä¼˜åŒ–**
   - ä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹æé«˜å¹¶å‘æ€§èƒ½
   - å®ç°ç¼“å­˜æœºåˆ¶å‡å°‘é‡å¤è®¡ç®—
   - ç›‘æ§å’Œä¼˜åŒ–å†…å­˜ä½¿ç”¨

4. **å®‰å…¨è€ƒè™‘**
   - å®ç°è¾“å…¥éªŒè¯å’Œæ¸…ç†
   - è®¾ç½®æ‰§è¡Œè¶…æ—¶å’Œèµ„æºé™åˆ¶
   - ä½¿ç”¨å®‰å…¨çš„APIè°ƒç”¨æ–¹å¼

5. **æµ‹è¯•ç­–ç•¥**
   - ç¼–å†™å•å…ƒæµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½
   - å®ç°é›†æˆæµ‹è¯•éªŒè¯æ¨¡å—åä½œ
   - è¿›è¡Œæ€§èƒ½æµ‹è¯•ç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§

### ğŸš€ éƒ¨ç½²æœ€ä½³å®è·µ

1. **å®¹å™¨åŒ–éƒ¨ç½²**
   - ä½¿ç”¨Dockerè¿›è¡Œåº”ç”¨å®¹å™¨åŒ–
   - ä½¿ç”¨Kubernetesè¿›è¡Œå®¹å™¨ç¼–æ’
   - å®ç°å¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨é‡å¯

2. **ç›‘æ§å’Œæ—¥å¿—**
   - é›†æˆPrometheuså’ŒGrafanaç›‘æ§
   - å®ç°ç»“æ„åŒ–æ—¥å¿—è®°å½•
   - è®¾ç½®å‘Šè­¦æœºåˆ¶

3. **é…ç½®ç®¡ç†**
   - ä½¿ç”¨ç¯å¢ƒå˜é‡ç®¡ç†é…ç½®
   - å®ç°é…ç½®çƒ­æ›´æ–°
   - åˆ†ç¦»æ•æ„Ÿä¿¡æ¯

4. **æ‰©å±•æ€§è®¾è®¡**
   - æ”¯æŒæ°´å¹³æ‰©å±•
   - å®ç°è´Ÿè½½å‡è¡¡
   - ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦

### ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å†…å­˜ç®¡ç†**
   - å®šæœŸæ¸…ç†çŸ­æœŸè®°å¿†
   - ä½¿ç”¨å†…å­˜æ˜ å°„æ–‡ä»¶å­˜å‚¨å¤§å¯¹è±¡
   - å®ç°å†…å­˜ä½¿ç”¨ç›‘æ§

2. **å¹¶å‘å¤„ç†**
   - ä½¿ç”¨å¼‚æ­¥I/Oæ“ä½œ
   - å®ç°ä»»åŠ¡é˜Ÿåˆ—å¤„ç†
   - åˆç†è®¾ç½®å¹¶å‘é™åˆ¶

3. **ç¼“å­˜ç­–ç•¥**
   - ç¼“å­˜é¢‘ç¹è®¿é—®çš„æ•°æ®
   - å®ç°æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
   - ä½¿ç”¨åˆ†å¸ƒå¼ç¼“å­˜

---

## ğŸ¯ æ€»ç»“

æœ¬æ¨¡æ¿åŸºäºå¯¹30ä¸ªå¼€æºæ™ºèƒ½ä½“æ¡†æ¶çš„æ·±åº¦åˆ†æï¼Œæä¾›äº†å®Œæ•´çš„æ™ºèƒ½ä½“å¼€å‘æ¶æ„å’Œæœ€ä½³å®è·µã€‚é€šè¿‡éµå¾ªè¿™ä¸ªæ¨¡æ¿ï¼Œæ‚¨å¯ä»¥ï¼š

1. **å¿«é€Ÿå¯åŠ¨**ï¼šä½¿ç”¨æä¾›çš„ä»£ç æ¨¡æ¿å¿«é€Ÿæ­å»ºæ™ºèƒ½ä½“é¡¹ç›®
2. **æ ‡å‡†åŒ–å¼€å‘**ï¼šéµå¾ªç»Ÿä¸€çš„æ¶æ„æ¨¡å¼å’Œå¼€å‘è§„èŒƒ
3. **é«˜æ•ˆéƒ¨ç½²**ï¼šä½¿ç”¨å®¹å™¨åŒ–å’Œç›‘æ§æ–¹æ¡ˆç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§
4. **æŒç»­ä¼˜åŒ–**ï¼šåŸºäºç›‘æ§æ•°æ®è¿›è¡Œæ€§èƒ½ä¼˜åŒ–å’ŒåŠŸèƒ½è¿­ä»£

é€‰æ‹©é€‚åˆæ‚¨éœ€æ±‚çš„æŠ€æœ¯æ ˆï¼ŒæŒ‰ç…§æ¨¡æ¿è¿›è¡Œå¼€å‘ï¼Œæ‚¨å°†èƒ½å¤Ÿæ„å»ºå‡ºé«˜è´¨é‡ã€å¯æ‰©å±•çš„æ™ºèƒ½ä½“ç³»ç»Ÿã€‚

---

*æœ¬æ¨¡æ¿åŸºäºå¼€æºæ™ºèƒ½ä½“é¡¹ç›®åˆ†ææŠ¥å‘Šï¼ŒæŒç»­æ›´æ–°ä¸­ã€‚å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åé¦ˆã€‚*
